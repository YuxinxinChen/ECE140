(defun isLL2 (q)
	      (cond ((listp q) (= 2 (length q)))
		    (t nil)
	      )
) 

(defun isLL2a (q)
	      (cond ((listp q) (and (listp (cadr q)) (= 2 (length q)) ))
		    (t nil)
	      )
)

(defun isLpairs-recursive (q)
	(cond ((listp q)
		(let ((temp (car q)))
                     ;(print temp)
		     (cond ( (and (listp temp) (= 2 (length temp) )) 
			     ( cond ( (null (cdr q)) t) 
				    ( t (isLpairs-recursive (cdr q))  )
		             )
		           )
			   ( (null temp) t)
		           (t nil)
                     )
	         )
               )
               (t nil)
        )
)

(defun isLpairs-iterative (q)
     (cond ((not (listp q)) nil)
	   (t 
		(do ( (q1 q (cdr q1))
		      (res t (setq res (and (listp (car q1)) (= 2 (length (car q1))))))
		    )
		    ((or (null res) (null q1)) res)
		)
           )
     )
)

(defun isLpairs-every (q)
	(cond ((not (listp q)) nil)
	      (t 
		(every #'(lambda (q) (and (listp q) (= 2 (length q)))) q)
	      )
	)
)

(defun isLpairs1st-recursive (q)
	(cond ( (null (isLpairs-recursive q)) nil)
	      ( t (let ((temp (car (car q))))
		   (defun checkFirst (q z) 
			   (cond ( (null q) t)
				 ((equal z (car (car q))) (checkFirst (cdr q) z) )
			   	 ( t nil)
			   )
		   )
		   (checkFirst q temp)
		  )
	      )
        )
)

(defun isLpairs1st-iterative (q)
    	(cond ( (null (isLpairs-iterative q)) nil)
	      ( t (let ((temp (car (car q))))
		   (do ( (q1 q (cdr q1))
			 (res t (setq res (equal (car (car q1)) temp)))
		       )
	               ((or (null res) (null q1)) res)
		   )
	          )
	      )
	)
)

(defun isLpairs1st-every (q)
	(cond ( (null (isLpairs-every q)) nil)
	      ( t (let ((temp (car (car q))))
		   ;(print temp)
		   (every #'(lambda (q) (equal (car q) temp)) q)
	      	  )
	      )
        )
)

(defun distribute-recursive (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
			(defun combine (rest)
			       (cond ( (null rest) nil)
				     ( t (cons (list firstElem (car rest)) (combine (cdr rest))))
			       )
			)
			(combine (car (cdr q)))
		   )
	       )
	)
)

(defun distribute-iterative (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
		   	(do ( (q1 (car (cdr q)) (cdr q1))
			      (res nil (cons (list firstElem (car q1)) res))
			    )
			    ( (null q1) (reverse res))
		        )
		  )
	      )
	)
)

(defun distribute-mapcar (q)
	(cond ( (null (isLL2a q)) nil) 
	      ( t (let ((firstElem (car q)))
			(mapcar #'(lambda (x) (list firstElem x)) (car (cdr q)))
		   )
	      )
	)
)

(defun undistribute-recursive (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (defun collect (q)
		            (cond ( (null q) nil)
				  ( t (append (cdr (car q)) (collect (cdr q))))
		            )
                    )
		    (list firstElem (collect q))
		  )
 	      )
    	)
)

(defun undistribute-iterative (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		(do ( (q1 q (cdr q1))
		      (res nil (append res (cdr (car q1))))
		    )
		    ((null q1) (list firstElem res))
		)
	       )
              )
       	)
)

(defun undistribute-mapcar (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (let ((res nil))
			(mapcar #'(lambda (x) (setq res (append res (cdr x)))) q)
		     	(list firstElem res)
		     )
	          )
               )
	)
)

(defun my-every (fun q)
		(cond ((null q) t)
	      	       ((null (funcall fun (car q))) nil)
	      		( t (my-every fun (cdr q)))
	)
)


(defun lenLL (q)
	(cond ((not (listp q)) 0)
	      (t (let ((maxsublist (length q)))
			;(print 'maxsublist)
		     ;(print maxsublist)
		  (labels ((rec (q) 
			    (cond 
				  ( (null q) maxsublist)
				  ( (not (listp (car q))) (rec (cdr q)))
				  ( t (let ((temp (lenLL (car q)))) (cond ( (> temp maxsublist) (setq maxsublist temp)))
						(rec (cdr q))
				      ) 
			          )
			    )
		          ))
		   	  (rec q)
		   )

		  )
	       )
	)
)

;(defun lenLL (q)
;	(cond ((not (listp q)) 0)
;	      (t (let ((maxsublist (length q)))
;			(defun rec (q)
;				(cond ( (null q) maxsublist)
;				      ( (not (listp (car q))) (rec (cdr q)))
;				      ( t (cond ((> (length (car q)) maxsublist) (setq maxsublist (length (car q))) )
;					  ) (rec (cdr q))
;					 
;				      )
;			 	)	
;			)
;			(rec q)
;		  )
;	       )
;	)
;)		

(defun my-mapper (pred lst-a lst-b)
(let ((temp nil))
  (labels ((rec (a b acc)
                (if (and a b)
                    (rec (cdr a) (cdr b)
                         (cons (funcall pred (car a) (car b)) acc))
                  acc)))
    (rec lst-a lst-b nil)
  )
)
)
			    
	


                    





