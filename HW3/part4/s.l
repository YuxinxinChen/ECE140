(defun isLL2 (q)
	      (cond ((listp q) (= 2 (length q)))
		    (t nil)
	      )
) 

(defun isLL2a (q)
	      (cond ((listp q) (and (listp (cadr q)) (= 2 (length q)) ))
		    (t nil)
	      )
)

(defun isLpairs-recursive (q)
	(cond ((listp q)
		(let ((temp (car q)))
                     ;(print temp)
		     (cond ( (and (listp temp) (= 2 (length temp) )) 
			     ( cond ( (null (cdr q)) t) 
				    ( t (isLpairs-recursive (cdr q))  )
		             )
		           )
			   ( (null temp) t)
		           (t nil)
                     )
	         )
               )
               (t nil)
        )
)

(defun isLpairs-iterative (q)
     (cond ((not (listp q)) nil)
	   (t 
		(do ( (q1 q (cdr q1))
		      (res t (setq res (and (listp (car q1)) (= 2 (length (car q1))))))
		    )
		    ((or (null res) (null q1)) res)
		)
           )
     )
)

(defun isLpairs-every (q)
	(cond ((not (listp q)) nil)
	      (t 
		(every #'(lambda (q) (and (listp q) (= 2 (length q)))) q)
	      )
	)
)

(defun isLpairs1st-recursive (q)
	(cond ( (null (isLpairs-recursive q)) nil)
	      ( t (let ((temp (car (car q))))
		   (defun checkFirst (q z) 
			   (cond ( (null q) t)
				 ((equal z (car (car q))) (checkFirst (cdr q) z) )
			   	 ( t nil)
			   )
		   )
		   (checkFirst q temp)
		  )
	      )
        )
)

(defun isLpairs1st-iterative (q)
    	(cond ( (null (isLpairs-iterative q)) nil)
	      ( t (let ((temp (car (car q))))
		   (do ( (q1 q (cdr q1))
			 (res t (setq res (equal (car (car q1)) temp)))
		       )
	               ((or (null res) (null q1)) res)
		   )
	          )
	      )
	)
)

(defun isLpairs1st-every (q)
	(cond ( (null (isLpairs-every q)) nil)
	      ( t (let ((temp (car (car q))))
		   ;(print temp)
		   (every #'(lambda (q) (equal (car q) temp)) q)
	      	  )
	      )
        )
)

(defun distribute-recursive (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
			(defun combine (rest)
			       (cond ( (null rest) nil)
				     ( t (cons (list firstElem (car rest)) (combine (cdr rest))))
			       )
			)
			(combine (car (cdr q)))
		   )
	       )
	)
)

(defun distribute-iterative (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
		   	(do ( (q1 (car (cdr q)) (cdr q1))
			      (res nil (cons (list firstElem (car q1)) res))
			    )
			    ( (null q1) (reverse res))
		        )
		  )
	      )
	)
)

(defun distribute-mapcar (q)
	(cond ( (null (isLL2a q)) nil) 
	      ( t (let ((firstElem (car q)))
			(mapcar #'(lambda (x) (list firstElem x)) (car (cdr q)))
		   )
	      )
	)
)

(defun undistribute-recursive (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (defun collect (q)
		            (cond ( (null q) nil)
				  ( t (append (cdr (car q)) (collect (cdr q))))
		            )
                    )
		    (list firstElem (collect q))
		  )
 	      )
    	)
)

(defun undistribute-iterative (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		(do ( (q1 q (cdr q1))
		      (res nil (append res (cdr (car q1))))
		    )
		    ((null q1) (list firstElem res))
		)
	       )
              )
       	)
)

(defun undistribute-mapcar (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (let ((res nil))
			(mapcar #'(lambda (x) (setq res (append res (cdr x)))) q)
		     	(list firstElem res)
		     )
	          )
               )
	)
)


	


                    





