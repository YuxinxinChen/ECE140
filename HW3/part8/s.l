(defun isLL2 (q)
	      (cond ((listp q) (= 2 (length q)))
		    (t nil)
	      )
) 

(defun isLL2a (q)
	      (cond ((listp q) (and (listp (cadr q)) (= 2 (length q)) ))
		    (t nil)
	      )
)

(defun isLpairs-recursive (q)
	(cond ((listp q)
		(let ((temp (car q)))
                     ;(print temp)
		     (cond ( (and (listp temp) (= 2 (length temp) )) 
			     ( cond ( (null (cdr q)) t) 
				    ( t (isLpairs-recursive (cdr q))  )
		             )
		           )
			   ( (null temp) t)
		           (t nil)
                     )
	         )
               )
               (t nil)
        )
)

(defun isLpairs-iterative (q)
     (cond ((not (listp q)) nil)
	   (t 
		(do ( (q1 q (cdr q1))
		      (res t (setq res (and (listp (car q1)) (= 2 (length (car q1))))))
		    )
		    ((or (null res) (null q1)) res)
		)
           )
     )
)

(defun isLpairs-every (q)
	(cond ((not (listp q)) nil)
	      (t 
		(every #'(lambda (q) (and (listp q) (= 2 (length q)))) q)
	      )
	)
)

(defun isLpairs1st-recursive (q)
	(cond ( (null (isLpairs-recursive q)) nil)
	      ( t (let ((temp (car (car q))))
		   (defun checkFirst (q z) 
			   (cond ( (null q) t)
				 ((equal z (car (car q))) (checkFirst (cdr q) z) )
			   	 ( t nil)
			   )
		   )
		   (checkFirst q temp)
		  )
	      )
        )
)

(defun isLpairs1st-iterative (q)
    	(cond ( (null (isLpairs-iterative q)) nil)
	      ( t (let ((temp (car (car q))))
		   (do ( (q1 q (cdr q1))
			 (res t (setq res (equal (car (car q1)) temp)))
		       )
	               ((or (null res) (null q1)) res)
		   )
	          )
	      )
	)
)

(defun isLpairs1st-every (q)
	(cond ( (null (isLpairs-every q)) nil)
	      ( t (let ((temp (car (car q))))
		   ;(print temp)
		   (every #'(lambda (q) (equal (car q) temp)) q)
	      	  )
	      )
        )
)

(defun distribute-recursive (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
			(defun combine (rest)
			       (cond ( (null rest) nil)
				     ( t (cons (list firstElem (car rest)) (combine (cdr rest))))
			       )
			)
			(combine (car (cdr q)))
		   )
	       )
	)
)

(defun distribute-iterative (q)
	(cond ( (null (isLL2a q)) nil)
	      ( t (let ((firstElem (car q)))
		   	(do ( (q1 (car (cdr q)) (cdr q1))
			      (res nil (cons (list firstElem (car q1)) res))
			    )
			    ( (null q1) (reverse res))
		        )
		  )
	      )
	)
)

(defun distribute-mapcar (q)
	(cond ( (null (isLL2a q)) nil) 
	      ( t (let ((firstElem (car q)))
			(mapcar #'(lambda (x) (list firstElem x)) (car (cdr q)))
		   )
	      )
	)
)

(defun undistribute-recursive (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (defun collect (q)
		            (cond ( (null q) nil)
				  ( t (append (cdr (car q)) (collect (cdr q))))
		            )
                    )
		    (list firstElem (collect q))
		  )
 	      )
    	)
)

(defun undistribute-iterative (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		(do ( (q1 q (cdr q1))
		      (res nil (append res (cdr (car q1))))
		    )
		    ((null q1) (list firstElem res))
		)
	       )
              )
       	)
)

(defun undistribute-mapcar (q)
	(cond ( (null (isLpairs1st-recursive q)) nil)
	      ( (null q) nil)
	      ( t (let ((firstElem (car (car q))))
		    (let ((res nil))
			(mapcar #'(lambda (x) (setq res (append res (cdr x)))) q)
		     	(list firstElem res)
		     )
	          )
               )
	)
)

(defun my-every (fun q)
		(cond ((null q) t)
	      	       ((null (funcall fun (car q))) nil)
	      		( t (my-every fun (cdr q)))
	)
)


(defun lenLL (q)
	(cond ((not (listp q)) 0)
	      (t (let ((maxsublist (length q)))
			;(print 'maxsublist)
		     ;(print maxsublist)
		  (labels ((rec (q) 
			    (cond 
				  ( (null q) maxsublist)
				  ( (not (listp (car q))) (rec (cdr q)))
				  ( t (let ((temp (lenLL (car q)))) (cond ( (> temp maxsublist) (setq maxsublist temp)))
						(rec (cdr q))
				      ) 
			          )
			    )
		          ))
		   	  (rec q)
		   )

		  )
	       )
	)
)

(defun simplify-not (x)
	(cond ((null x) nil)
	      ((not (listp x)) x)
	      (t ; x is list and get first element and rec on cdr
		( let ((carx (simplify-not (car x))) (res (simplify-not (cdr x)))) 
		  (cond ((and (equal 'not carx) (equal t (car res))) nil)
			((and (equal 'not carx) (equal nil (car res))) t)
			( t (cons carx res))
	      	  )
		)
	      )
	)
)

(defun simplify-not-2 (x)
	(cond ((null x) nil)
	      ((not (listp x)) x)
	      (t ; x is list and get first element and rec on cdr
		( let ((carx (simplify-not (car x))) (res (simplify (cdr x)))) 
		  (cond ((and (equal 'not carx) (equal t (car res))) nil)
			((and (equal 'not carx) (equal nil (car res))) t)
			( t (cons carx res))
	      	  )
		)
	      )
	)
)


(defun simplify (x)
	(cond
	    ( (null x) nil)
	    ( (not (listp x)) x)
	    ( (listp (car x)) (cons (simplify (car x)) (simplify (cdr x))) ) 
	    ( (equal 'and (car x)) 
		(cond ((null (cdr x)) t)
		      ( t (let ((unpack (mapcar #'(lambda (x) (cond ((listp x) (simplify x))
										(t x)
						  )
					) (cdr x))))
				;(print unpack)
			  	(let ((rem (remove t unpack)))
					;(print rem)
					(cond ((null rem) t)
					      ((not (null (member nil rem))) nil)
					      ((= 1 (length rem)) (car rem))
					      (t (append '(and) rem))
					)
				)
			  )
		      )
		)	
	     )
	     ( (equal 'or (car x))
		 (cond ((null (cdr x)) nil)
		       (t (let ((unpack (mapcar #'(lambda (x) (cond ((listp x) (simplify x))
								     ( t x)
								)
						   ) (cdr x))))
			  	;(print unpack)
				(let ((rem (remove nil unpack)))
		     			;(print rem)
				   	(cond ((not (null (member t rem))) t)
					      ((null rem) nil)
					      ((= 1 (length rem)) (car rem))
					      (t (append '(or) rem)) 
				   	)
			   	)
			   )
		       )
	          )
 	    )
	   ( (equal 'not (car x)) (simplify-not-2 x))
	   ( t 
		(let ((prev (remove-if #'(lambda (x) (and (listp x) (not (null x)))) x)) (later (remove-if #'(lambda (x) (or (not (listp x)) (null x))) x)))
			(append prev (simplify later)))
	   )
      )
)	


